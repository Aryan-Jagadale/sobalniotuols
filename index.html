<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>404 NOT FOUND</title>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <h1>PHASSSE 2</h1>
    <div class="cpp">
        #include <bits/stdc++.h>
using namespace std;

// Process Control Block
struct PCB
{
    int jobid;
    int TTL;
    int TLL;
    int TTC;
    int TLC;
} pcb;

class program
{
    char M[300][4];
    char IR[4];
    char R[4];
    int PTR[4];
    int IC, SI, TI, PI;
    char buffer[40];
    bool isAllocated[30];
    bool C;
    int flag;
    int EM;
    int RA;
    int ptc; // 0-9

public:
    void init();
    void load();
    int getloc();
    void startExecution();
    void executeUserProgram();
    void MOS();
    void read();
    void write();           // correct
    void terminate(int EM); // correct
    int addressMap(int VA); // correct
    int allocate();         // correct
    fstream Input;
    fstream Output;
};

void program::init()
{
    cout << "INIT()" << endl
         << endl;

    srand(time(0)); // c
    ptc = 0;        // counter for page table

    for (int i = 0; i < 300; i++) // c
    {
        for (int j = 0; j < 4; j++)
        {
            M[i][j] = '\0';
        }
    }

    C = false;

    IR[4] = {' '};

    R[4] = {' '};

    PTR[4] = {-1}; // c

    EM = 0;  // c
    RA = -1; // c
    TI = 0;  // c
    SI = 3;  // c
    PI = 0;  // c

    for (int i = 0; i < 30; i++) // CHANGES
    {
        isAllocated[i] = false;
    }

    // creating a PCB object and initializing the values

    // jobid
    pcb.jobid = ((buffer[4] - '0') * 1000) + ((buffer[5] - '0') * 100) + ((buffer[6] - '0') * 10) + (buffer[7] - '0');

    // TTL
    pcb.TTL = ((buffer[8] - '0') * 1000) + ((buffer[9] - '0') * 100) + ((buffer[10] - '0') * 10) + (buffer[11] - '0');

    // TLL
    pcb.TLL = ((buffer[12] - '0') * 1000) + ((buffer[13] - '0') * 100) + ((buffer[14] - '0') * 10) + (buffer[15] - '0');

    // TTC
    pcb.TTC = 0;

    // TLC
    pcb.TLC = 0;

    // printing the PCB
    cout << "\nPCB: " << endl;
    cout << "jobid:\t" << pcb.jobid << endl;
    cout << "TTL:\t" << pcb.TTL << endl;
    cout << "TLL:\t" << pcb.TLL << endl;
    cout << "TTC:\t" << pcb.TTC << endl;
    cout << "TLC:\t" << pcb.TLC << endl
         << endl;
}

int program::getloc()
{
    cout << "GETLOC()" << endl
         << endl;

    int mem = ((IR[2] - '0') * 10) + (IR[3] - '0');
    return mem;
}

int program::allocate()
{
    // cout << "ALLOCATE()" << endl
    //      << endl;

    int block = rand() % 30;

    while (isAllocated[block])
    {
        block = rand() % 30;
    }

    cout << "BLOCK: " << block << endl;
    return block;
}

void program::load()
{

    cout << "LOAD()" << endl
         << endl;
    if (Input.eof())
    {
        exit(0);
    }
    while (!Input.eof())
    {
        // initialising buffer
        for (int i = 0; i < 40; i++)
        {
            buffer[i] = '\0';
        }

        // reading from input file line by line
        Input.getline(buffer, 41);

        if (buffer[0] == '$' && buffer[1] == 'A' && buffer[2] == 'M' && buffer[3] == 'J')
        {
            cout << "$AMJ" << endl
                 << endl;

            init();
            flag = 0;
            // c
            // generating PTR
            Output << "------jobID: " << pcb.jobid << " initiated------\n\n";
            int ptr = allocate() * 10;

            // allocating PTR
            PTR[0] = ptr / 1000;
            PTR[1] = (ptr / 100) % 10;
            PTR[2] = (ptr / 10) % 10;
            PTR[3] = ptr % 10;
            cout << "PTR: " << ptr << endl;

            // initializing page table
            for (int i = ptr; i < ptr + 10; i++)
            {
                for (int j = 0; j < 4; j++)
                {
                    M[i][j] = '*';
                }
            }

            isAllocated[ptr / 10] = true; // CHANGES
        }
        else if (buffer[0] == '$' && buffer[1] == 'D' && buffer[2] == 'T' && buffer[3] == 'A')
        {
            cout << "$DTA" << endl
                 << endl;

            startExecution();
        }
        else if (buffer[0] == '$' && buffer[1] == 'E' && buffer[2] == 'N' && buffer[3] == 'D')
        {
            flag = 1;
            cout << "$END" << endl
                 << endl;
            int x = 0;
            for (int i = 0; i < 300; i++)
            {
                cout << "M" << x << ": " << M[i][0] << M[i][1] << M[i][2] << M[i][3] << endl;
                x++;
            }

            // printing the PCB
            cout << "\nPCB: " << endl;
            cout << "jobid:\t" << pcb.jobid << endl;
            cout << "TTL:\t" << pcb.TTL << endl;
            cout << "TLL:\t" << pcb.TLL << endl;
            cout << "TTC:\t" << pcb.TTC << endl;
            cout << "TLC:\t" << pcb.TLC << endl
                 << endl;

            Output << "\nPCB: " << endl;
            Output << "jobid:\t" << pcb.jobid << endl;
            Output << "TTL:\t" << pcb.TTL << endl;
            Output << "TLL:\t" << pcb.TLL << endl;
            Output << "TTC:\t" << pcb.TTC << endl;
            Output << "TLC:\t" << pcb.TLC << endl
                   << endl;

            cout << "---job ID: " << pcb.jobid << " ENDED!!---" << endl
                 << endl;
            Output << "---job ID: " << pcb.jobid << " ENDED!!---" << endl
                   << endl;

            init();
            break;
        }
        else
        {
            if (flag == 0)
            {
                // reading from the program card
                cout << "READING FROM THE PROGRAM CARD" << endl
                     << endl;

                // get frame for program page
                int block = allocate(); // returns block [0-29] //c
                cout << "block: " << block << endl;
                int loc = block * 10;
                cout << "loc: " << loc << endl;

                // updating page table

                int PTE = ((PTR[1] * 100) + (PTR[2] * 10) + PTR[3]) + ptc;
                isAllocated[block] = true; // CHANGES
                ptc++;                     // c
                cout << "PTE: " << PTE << endl;

                M[PTE][2] = (block / 10) + '0';

                M[PTE][3] = (block % 10) + '0';
                cout << "M[PTE] : " << M[PTE][2] << M[PTE][3] << endl;

                int k = 0;
                for (int i = loc; i < loc + 10; i++)
                {
                    for (int j = 0; j < 4; j++)
                    {
                        // error handling for when the OP_CODE is 'H'
                        if (buffer[k] == 'H')
                        {
                            M[i][j] = buffer[k];
                            k++;
                            break;
                        }
                        else
                        {
                            M[i][j] = buffer[k];
                            k++;
                        }
                    }

                    if (k == 40 || buffer[k] == ' ' || buffer[k] == '\0')
                    {
                        break;
                    }
                }
            }
            else
            {
                continue;
            }
        }
    }

    cout << "END LOAD" << endl
         << endl;
}

void program::startExecution()
{
    cout << "STARTEXECUTION()" << endl
         << endl;
    IC = 00;
    executeUserProgram();
}

int program::addressMap(int VA)
{
    cout << "ADDRESSMAP()" << endl
         << endl;
    // checking for operand error
    if (VA < 0 || VA > 99)
    {
        PI = 2;
        MOS();
    }

    int PTE = (VA / 10) + ((PTR[1] * 100) + (PTR[2] * 10) + (PTR[3]));
    cout << "PTE :" << PTE << endl;

    RA = ((M[PTE][2] - '0') * 10 + (M[PTE][3] - '0')) * 10 + (VA % 10); // CHANGES
    cout << "VA :" << VA << endl;
    cout << "RA : " << RA << endl
         << endl;
    // -----PROBLEM HERE------
    // checking for page fault error
    if (!isAllocated[RA / 10]) // CHANGES
    {
        PI = 3;
        MOS();
    }

    return RA;
}

void program::executeUserProgram()
{
    cout << "EXECUTEUSERPROGRAM()" << endl
         << endl;
    while (PI == 0 && TI == 0)
    {

        RA = addressMap(IC);
        if (PI != 0)
        {
            break;
        }

        IR[0] = M[RA][0]; // CHANGES
        IR[1] = M[RA][1];
        IR[2] = M[RA][2];
        IR[3] = M[RA][3];
        IC++;

        if (IR[0] == 'H')
        {
            SI = 3;
            pcb.TTC++;
            MOS();
            break;
        }
        else
        {

            RA = addressMap(((IR[2] - '0') * 10 + (IR[3] - '0')));

            if (PI != 0)
            {
                break;
            }

            cout << "NO PI ERROR " << endl
                 << endl;
            if (IR[0] == 'P' && IR[1] == 'D')
            {
                SI = 2;
                MOS();
                pcb.TTC++;
            }
            else if (IR[0] == 'G' && IR[1] == 'D')
            {
                cout << "GD here" << endl
                     << endl;
                SI = 1;
                MOS();
            }
            else if (IR[0] == 'L' && IR[1] == 'R')
            {

                for (int i = 0; i < 4; i++)
                {
                    R[i] = M[RA][i];
                }

                pcb.TTC++;
            }
            else if (IR[0] == 'S' && IR[1] == 'R')
            {

                for (int i = 0; i < 4; i++)
                {
                    M[RA][i] = R[i];
                }

                pcb.TTC += 2;
            }
            else if (IR[0] == 'B' && IR[1] == 'T')
            {
                if (C)
                {
                    int loc = getloc();

                    IC = loc;
                }

                pcb.TTC++;
            }
            else if (IR[0] == 'C' && IR[1] == 'R')
            {

                if (R[0] == M[RA][0] && R[1] == M[RA][1] && R[2] == M[RA][2] && R[3] == M[RA][3])
                {
                    C = true;
                }
                else
                {
                    C = false;
                }

                pcb.TTC++;
            }
            else if (IR[0]=='H' && IR[1] == '\0')
            {
                SI = 3 ;
                MOS();

            }
            
            else
            {
                PI = 1;
                MOS();
            }
        }

        // checking for TLE
        if (pcb.TTC > pcb.TTL)
        {
            TI = 2;
            MOS();
        }
    }
}

void program::MOS()
{
    cout << "MOS()" << endl
         << endl;
    // Output << "MOS() called....\n";
    // Output << "INTERRUPT VALUES:\n";
    // Output << "SI: " << SI <<endl;
    // Output << "PI: " << PI <<endl;
    // Output << "TI: " << TI <<endl << endl;

    // TI and PI
    if (TI == 0 && PI == 1)
    {
        terminate(4);
    }
    else if (TI == 0 && PI == 2)
    {
        terminate(5);
    }
    else if (TI == 0 && PI == 3)
    {

        // check if valid
        if (IR[0] == 'G' && IR[1] == 'D' || IR[0] == 'S' && IR[1] == 'R')
        {
            cout << "INSIDE MOS() : VALID PAGE FAULT" << endl;
            Output << "Error: VALID PAGE FAULT, REALLOCATING....\n";

            // ---PROBLEM HERE----
            int block = allocate();

            int PTE = ((PTR[1] * 100) + (PTR[2] * 10) + PTR[3]) + ptc;
            isAllocated[block] = true; // CHANGES
            ptc++;                     // c
            cout << "PTE: " << PTE << endl;

            M[PTE][2] = (block / 10) + '0';

            M[PTE][3] = (block % 10) + '0';
            cout << "M[PTE] : " << M[PTE][2] << M[PTE][3] << endl;

            IC--;
            PI = 0; // c

            // incrementing the TTC
            pcb.TTC++;
            executeUserProgram(); // CHANGES
            return;
        }
        else
        {
            terminate(6);
        }
    }
    else if (TI == 2 && PI == 1)
    {
        Output << "Operation Code Error" << endl;
        terminate(3);
    }
    else if (TI == 2 && PI == 2)
    {
        Output << "Operand Error" << endl;
        terminate(3);
    }
    else if (TI == 2 && PI == 3)
    {
        terminate(3);
    }

    // TI and SI
    if (TI == 0 && SI == 1)
    {
        read();
    }
    else if (TI == 0 && SI == 2)
    {
        write();
    }
    else if (TI == 0 && SI == 3)
    {
        terminate(0);
    }
    else if (TI == 2 && SI == 1)
    {
        terminate(3);
    }
    else if (TI == 2 && SI == 2)
    {
        write();
        terminate(3);
    }
    else if (TI == 2 && SI == 3)
    {
        terminate(0);
    }

    // PI = 0, SI = 0, TI = 0;
}

void program::read()
{
    cout << "READ()" << endl
         << endl;
    for (int i = 0; i < 40; i++)
    {
        buffer[i] = '\0';
    }
    // reading data from data card and putting it into buffer
    Input.getline(buffer, 41);

    if (buffer[0] == '$' && buffer[1] == 'E' && buffer[2] == 'N' && buffer[3] == 'D')
    {
        terminate(1); // c
    }

    // // reading OP_CODE from IR and converting it into int data type

    int k = 0;
    for (int l = RA; l < RA + 10; l++) // c
    {
        for (int j = 0; j < 4; j++)
        {
            M[l][j] = buffer[k];
            k++;
        }
    }
    // incrementing the TTC
    pcb.TTC++;
    // executeUserProgram();
    return;
}

void program::write()
{
    cout << "WRITE()" << endl
         << endl;
    // incrementing TLC
    pcb.TLC++; // c

    // checking for LLE
    if (pcb.TLC > pcb.TLL)
    { // c
        terminate(2);
    }

    for (int i = 0; i < 40; i++)
    {
        buffer[i] = '\0';
    }

    // reading data from Memory and putting it into buffer
    int k = 0;
    for (int l = RA; l < RA + 10; l++) // c
    {
        for (int j = 0; j < 4; j++)
        {
            buffer[k] = M[l][j];
            k++;
        }
    }

    // printing buffer data to output.txt
    string output = "";
    for (int i = 0; i < 40; i++)
    {
        if (buffer[i] != '\0')
        {
            output += buffer[i];
        }
    }

    cout << "output: " << output << endl;

    Output << "Output: " << output;
    Output << "\n";
    SI = 0;
}

void program::terminate(int EM)
{
    if (flag == 0)
    {
        cout << "TERMINATE()" << endl
             << endl;
        // Output << "terminating....\n";
        if (EM == 0) // c
        {
            Output << "jobID: " << pcb.jobid << " No Error\n\n";
            cout << "jobID: " << pcb.jobid << " No Error\n";
        }
        else if (EM == 1)
        {
            Output << "jobID: " << pcb.jobid << " Out of Data\n\n";
            cout << "jobID: " << pcb.jobid << " Out of Data\n";

            Output << "\nPCB: " << endl;
            Output << "jobid:\t" << pcb.jobid << endl;
            Output << "TTL:\t" << pcb.TTL << endl;
            Output << "TLL:\t" << pcb.TLL << endl;
            Output << "TTC:\t" << pcb.TTC << endl;
            Output << "TLC:\t" << pcb.TLC << endl
                   << endl;
        }
        else if (EM == 2)
        {
            Output << "jobID: " << pcb.jobid << " Line Limit Exceeded\n\n";
            cout << "jobID: " << pcb.jobid << " Line Limit Exceeded\n";
        }
        else if (EM == 3)
        {
            Output << "jobID: " << pcb.jobid << " Time Limit Exceeded\n\n";
            cout << "jobID: " << pcb.jobid << " Time Limit Exceeded\n";
        }
        else if (EM == 4)
        {
            Output << "jobID: " << pcb.jobid << " Operation Code Error\n\n";
            cout << "jobID: " << pcb.jobid << " Operation Code Error\n";
        }
        else if (EM == 5)
        {
            Output << "jobID: " << pcb.jobid << " Operand Error\n\n";
            cout << "jobID: " << pcb.jobid << " Operand Error\n";
        }
        else if (EM == 6)
        {
            Output << "jobID: " << pcb.jobid << " Invalid Page Fault\n\n";
            cout << "jobID: " << pcb.jobid << " Invalid Page Fault\n";
        }
    }

    flag = 1;
    load();
    // return;
}

int main()
{

    cout << "MAIN()" << endl
         << endl;
    program prog;

    prog.Input.open("input.txt", ios::in);
    prog.Output.open("output.txt", ios::app);

    if (!prog.Input)
    {
        cout << "File cannot open\n";
    }
    else
    {
        cout << "File Exist \n";
    }
    prog.load();
    prog.Input.close();
    prog.Output.close();
    return 0;
}


    </div>

    <div class="input">
        $AMJ000100080002
GD10PD10GD20PD20H
$DTA
VIT
VIIT
$END0001
$AMJ000200100002
GD10PD10GD20PD20H
$DTA
VIT
VIIT
$END0002
$AMJ000300080002
GD10YD10GD20PD20H
$DTA
VIT
$END0003
$AMJ000400080002
GD101PD10GD20PD20H
$DTA
VIT
VIIT
$END0004
$AMJ000500080002
GD10PD40GD20PD20H
$DTA
VIT
VIIT
$END0005
$AMJ000600080002
GD10TD10GD20PD20H
$DTA
VIT
VIIT
$END0006
$AMJ000700080001
GD10PD10GD20PD20H
$DTA
VIT
VIIT
$END0007





    </div>




    <h1>READER WRITER MUTEX</h1>
    <div>
        #include-stdio.h-
        #include-pthread.h-
        #include-string.h-
        int hours=23,mins=59,secs=53;
        void update();
        void display();
        pthread_mutex_t timer_lock;
        int main(void)
        {
            void *status;
            pthread_t r_thr,w_thr;
            pthread_mutex_init(&timer_lock,0);
            pthread_create(&r_thr,NULL,(void *)&display,(void *)NULL);
            pthread_create(&w_thr,NULL,(void *)&update,(void *)NULL);
            pthread_join(r_thr,&status);
            pthread_join(w_thr,&status);
        }
        
        void update()
        {
            void *status;
            while(1)
            {
                pthread_mutex_lock(&timer_lock);
                secs=secs+1;
                if(secs==60)
                {
                        mins=mins+1;
                        secs=0;
                }
                if(mins==60)
                {
                        hours=hours+1;
                        mins=0;
                }
                if(hours==24)
                {
                        hours=0;
                }
            pthread_mutex_unlock(&timer_lock);
            sleep(1);
            }
            pthread_exit(&status);
        }
        
        void display()
        {
            void *status;
            while(1)
            {
                pthread_mutex_lock(&timer_lock);
                printf("\n DISPLAY:");
                printf("\t %d %d %d",hours,mins,secs);
                pthread_mutex_unlock(&timer_lock);
                // sleep(1);
            }
            pthread_exit(&status);
        }
    </div>
    <h1>PRODUCER CONSUMER MUTEX</h1>
    <div>
        #include-stdio.h-
        #include-pthread.h-
        #include-string.h-
        #include-semaphore.h-
        
        char buffer[20];
        void *produce();
        void *consume();
        pthread_mutex_t mut;
        
        int main()
        {
            void *status;
            pthread_t p_thr,c_thr;
            pthread_mutex_init(&mut,0);
            pthread_create(&p_thr,NULL,(void*)&produce,NULL);
            pthread_create(&c_thr,NULL,(void*)&consume,NULL);
            pthread_join(p_thr,&status);
            pthread_join(c_thr,&status);
            return 0;
        }
        
        void *produce()
        {
            char str[20];
        
            while(1)
            {    
                    
                pthread_mutex_lock(&mut);
                    printf("\nENTER A STRING:");
            scanf("%s",str);
        
                strcpy(buffer,str);
                pthread_mutex_unlock(&mut);
                sleep(1);
            }
        
        }
        
        void *consume()
        {
                char str1[20];
        
                while(1)
                {
                    pthread_mutex_lock(&mut);
                    strcpy(str1,buffer);
                    printf("\nTHE CONSUMED STRING IS :%s",str1);
                    pthread_mutex_unlock(&mut);
                    sleep(1);
                }
        
        }
    </div>
    <h1>READER WRITER SEMAPHORE</h1>
    <div>
        #include -stdio.h-
        #include -pthread.h>
        #include -semaphore.h-
        #include -unistd.h-
        sem_t r, w;
        int h = 23, m = 59, s = 55;
        void *reader(), *writer();
        int main()
        {
            pthread_t rth, wth;
            void *status;
            sem_init(&r, 0, 0);
            sem_init(&w, 0, 1);
        
            pthread_create(&rth, NULL, (void *)&reader, NULL);
            pthread_create(&wth, NULL, (void *)&writer, NULL);
            pthread_join(rth, status);
            pthread_join(wth, status);
            sem_destroy(&w);
            sem_destroy(&r);
        }
        
        void *writer()
        {
            while (1)
            {
                sem_wait(&w);
                s = s + 1;
                if (s == 60)
                {
                    m++;
                    s = 0;
                }
                if (m == 60)
                {
                    h++;
                    m = 0;
                }
                if (h == 24)
                {
                    h = 1;
                }
                // sleep(1);
                sem_post(&r);
            }
        }
        
        void *reader()
        {
            while (1)
            {
                sem_wait(&r);
                printf("\n Display:\t");
                printf("%d:%d:%d", h, m, s);
                sem_post(&w);
            }
        }
    </div>
    <h1>PRODUCER CONSUMER SEMAPHORE</h1>
    <div>
        #include-stdio.h-
        #include-semaphore.h-
        #include-pthread.h-
        
        pthread_t producer_thr;
        pthread_t consumer_thr;
        sem_t full;
        sem_t empty;
        sem_t mutex;
        int buf[3],item_no=0,buf_index=0; 
        
        void *producer(){   
            int cntr;
            for(cntr=0;cntr< 5;cntr++){
                printf("Producer produced item %d\n",item_no);
                printf("Producer is checking if basket is having space\n");	
        
                if(buf_index==3)
                    printf("Producer cannot insert as basket is full\n");
        
                sem_wait(&empty);
            
                sem_wait(&mutex);
                printf("Producer is inserting item %d in the basket\n",item_no);
                buf[buf_index]=item_no;
                buf_index++;
                item_no++;
                sem_post(&mutex);
        
                sem_post(&full);
            }
        }
        void *consumer(){
            int item,cntr;
            for(cntr=0;cntr< 5;cntr++){
                printf("\tConsumer is checking if buffer is having an item\n");	
        
                if(buf_index==0)
                    printf("\tConsumer cannot consume as buffer is empty\n");
            
                sem_wait(&full);
            
                sem_wait(&mutex);
                item=buf[buf_index];
                printf("\tConsumer is removing item %d from the basket\n",item);
                buf_index--;
                sleep(3);
                sem_post(&mutex);
        
                sem_post(&empty);
            }
        }
        
        void main(){
            sem_init(&mutex,0,1);
            sem_init(&full,0,0);
            sem_init(&empty,0,3);
        
            pthread_create(&producer_thr,NULL,producer,NULL);
            pthread_create(&consumer_thr,NULL,consumer,NULL);
            
            pthread_join(producer_thr,NULL);
            pthread_join(consumer_thr,NULL);
        }
    </div>
    <h1>DINING PHILOSOPHER SEMAPHORE</h1>
    <div>
        #include -stdio.h-
        #include -stdlib.h-
        #include -pthread.h-
        #include -semaphore.h-
        #define NUM_PHILOSOPHERS 5
        #define NUM_CHOPSTICKS 5
        
        void dine(int n);
        pthread_t philosopher[NUM_PHILOSOPHERS];
        pthread_mutex_t chopstick[NUM_CHOPSTICKS];
        
        int main()
        {
            int i, status_message;
            void *msg;
        
            for (i = 1; i <= NUM_CHOPSTICKS; i++)
            {
            status_message = pthread_mutex_init(&chopstick[i], NULL);
            if (status_message == -1)
            {
                printf("\n Mutex initialization failed");
                exit(1);
            }
            }
        
            for (i = 1; i <= NUM_PHILOSOPHERS; i++)
            {
            status_message = pthread_create(&philosopher[i], NULL, (void *)dine, (int *)i);
            if (status_message != 0)
            {
                printf("\n Thread creation error \n");
                exit(1);
            }
            }
        
            for (i = 1; i <= NUM_PHILOSOPHERS; i++)
            {
            status_message = pthread_join(philosopher[i], &msg);
            if (status_message != 0)
            {
                printf("\n Thread join failed \n");
                exit(1);
            }
            }
        
            for (i = 1; i <= NUM_CHOPSTICKS; i++)
            {
            status_message = pthread_mutex_destroy(&chopstick[i]);
            if (status_message != 0)
            {
                printf("\n Mutex Destroyed \n");
                exit(1);
            }
            }
            return 0;
        }
        void dine(int n)
        {
            printf("\nPhilosopher % d is thinking ", n);
        
            pthread_mutex_lock(&chopstick[n]);
        
            pthread_mutex_lock(&chopstick[(n + 1) % NUM_CHOPSTICKS]);
        
            printf("\nPhilosopher % d is eating ", n);
            sleep(3);
        
            pthread_mutex_unlock(&chopstick[n]);
        
            pthread_mutex_unlock(&chopstick[(n + 1) % NUM_CHOPSTICKS]);
        
            printf("\nPhilosopher % d Finished eating ", n);
        }
    </div>
    <h1>FCFS</h1>
    <div>
        #include -iostream-
        using namespace std;
            
        void findWaitingTime(int processes[], int n,
                            int bt[], int wt[])
        {
            
            wt[0] = 0;
            
            for (int i = 1; i < n; i++)
                wt[i] = bt[i - 1] + wt[i - 1];
        }
        void findTurnAroundTime(int processes[], int n,
                                int bt[], int wt[], int tat[])
        {
            
            for (int i = 0; i < n; i++)
                tat[i] = bt[i] + wt[i];
        }
            
        void findavgTime(int processes[], int n, int bt[])
        {
            int wt[n], tat[n], total_wt = 0, total_tat = 0;
            
            findWaitingTime(processes, n, bt, wt);
            
            findTurnAroundTime(processes, n, bt, wt, tat);
            
            cout << "Processes  "
                << " Burst time  "
                << " Waiting time  "
                << " Turn around time\n";
            
            for (int i = 0; i < n; i++)
            {
                total_wt = total_wt + wt[i];
                total_tat = total_tat + tat[i];
                cout << "   " << i + 1 << "\t\t" << bt[i] << "\t    "
                    << wt[i] << "\t\t  " << tat[i] << endl;
            }
            
            cout << "Average waiting time = "
                << (float)total_wt / (float)n;
            cout << "\nAverage turn around time = "
                << (float)total_tat / (float)n;
        }
            
        int main()
        {
            
            int processes[] = {1, 2, 3};
            int n = sizeof processes / sizeof processes[0];
            
            int burst_time[] = {10, 5, 8};
            
            findavgTime(processes, n, burst_time);
            return 0;
        }
    </div>
    <h1>SJF</h1>
    <div>
        #include -stdio.h-
        int main()
        {
            int A[100][4];
            int i, j, n, total = 0, index, temp;
            float avg_wt, avg_tat;
            printf("Enter number of process: ");
            scanf("%d", &n);
            printf("Enter Burst Time:\n");
        
            for (i = 0; i < n; i++)
            {
                printf("P%d: ", i + 1);
                scanf("%d", &A[i][1]);
                A[i][0] = i + 1;
            }
        
            for (i = 0; i < n; i++)
            {
                index = i;
                for (j = i + 1; j < n; j++)
                    if (A[j][1] < A[index][1])
                        index = j;
                temp = A[i][1];
                A[i][1] = A[index][1];
                A[index][1] = temp;
        
                temp = A[i][0];
                A[i][0] = A[index][0];
                A[index][0] = temp;
            }
            A[0][2] = 0;
        
            for (i = 1; i < n; i++)
            {
                A[i][2] = 0;
                for (j = 0; j < i; j++)
                    A[i][2] += A[j][1];
                total += A[i][2];
            }
            avg_wt = (float)total / n;
            total = 0;
            printf("P     BT     WT     TAT\n");
        
            for (i = 0; i < n; i++)
            {
                A[i][3] = A[i][1] + A[i][2];
                total += A[i][3];
                printf("P%d     %d     %d      %d\n", A[i][0],
                        A[i][1], A[i][2], A[i][3]);
            }
            avg_tat = (float)total / n;
            printf("Average Waiting Time= %f", avg_wt);
            printf("\nAverage Turnaround Time= %f", avg_tat);
        }
    </div>
    <h1>ROUND ROBIN</h1>
    <div>
        #include -iostream-
        using namespace std;
        
        void findWaitingTime(int processes[], int n,
                                int bt[], int wt[], int quantum)
        {
        
            int rem_bt[n];
            for (int i = 0; i < n; i++)
                rem_bt[i] = bt[i];
        
            int t = 0;
        
            while (1)
            {
                bool done = true;
        
                for (int i = 0; i < n; i++)
                {
        
                    if (rem_bt[i] > 0)
                    {
                        done = false;
        
                        if (rem_bt[i] > quantum)
                        {
        
                            t += quantum;
        
                            rem_bt[i] -= quantum;
                        }
        
                        else
                        {
        
                            t = t + rem_bt[i];
        
                            wt[i] = t - bt[i];
        
                            rem_bt[i] = 0;
                        }
                    }
                }
        
                if (done == true)
                    break;
            }
        }
        void findTurnAroundTime(int processes[], int n,
                                int bt[], int wt[], int tat[])
        {
        
            for (int i = 0; i < n; i++)
                tat[i] = bt[i] + wt[i];
        }
        
        void findavgTime(int processes[], int n, int bt[],
                            int quantum)
        {
            int wt[n], tat[n], total_wt = 0, total_tat = 0;
        
            findWaitingTime(processes, n, bt, wt, quantum);
        
            findTurnAroundTime(processes, n, bt, wt, tat);
        
            cout << "PN\t "
                    << " \tBT "
                    << "  WT "
                    << " \tTAT\n";
        
            for (int i = 0; i < n; i++)
            {
                total_wt = total_wt + wt[i];
                total_tat = total_tat + tat[i];
                cout << " " << i + 1 << "\t\t" << bt[i] << "\t "
                        << wt[i] << "\t\t " << tat[i] << endl;
            }
        
            cout << "Average waiting time = "
                    << (float)total_wt / (float)n;
            cout << "\nAverage turn around time = "
                    << (float)total_tat / (float)n;
        }
        
        int main()
        {
        
            int processes[] = {1, 2, 3};
            int n = sizeof processes / sizeof processes[0];
        
            int burst_time[] = {10, 5, 8};
        
            int quantum = 2;
            findavgTime(processes, n, burst_time, quantum);
            return 0;
        }
    </div>
    <h1>PRIORITY SCHEDULING</h1>
    <div>
        #include-bits/stdc++.h-
        using namespace std;
        
        struct Process
        {
            int pid;  // Process ID
            int bt;   // CPU Burst time required
            int priority; // Priority of this process
        };
        
        // Function to sort the Process acc. to priority
        bool comparison(Process a, Process b)
        {
            return (a.priority > b.priority);
        }
        
        // Function to find the waiting time for all
        // processes
        void findWaitingTime(Process proc[], int n,
                            int wt[])
        {
            // waiting time for first process is 0
            wt[0] = 0;
        
            // calculating waiting time
            for (int  i = 1; i < n ; i++ )
                wt[i] =  proc[i-1].bt + wt[i-1] ;
        }
        
        // Function to calculate turn around time
        void findTurnAroundTime( Process proc[], int n,
                                int wt[], int tat[])
        {
            // calculating turnaround time by adding
            // bt[i] + wt[i]
            for (int  i = 0; i < n ; i++)
                tat[i] = proc[i].bt + wt[i];
        }
        
        //Function to calculate average time
        void findavgTime(Process proc[], int n)
        {
            int wt[n], tat[n], total_wt = 0, total_tat = 0;
        
            //Function to find waiting time of all processes
            findWaitingTime(proc, n, wt);
        
            //Function to find turn around time for all processes
            findTurnAroundTime(proc, n, wt, tat);
        
            //Display processes along with all details
            cout << "\nProcesses  "<< " Burst time  "
                << " Waiting time  " << " Turn around time\n";
        
            // Calculate total waiting time and total turn
            // around time
            for (int  i=0; i< n; i++)
            {
                total_wt = total_wt + wt[i];
                total_tat = total_tat + tat[i];
                cout << "   " << proc[i].pid << "\t\t"
                    << proc[i].bt << "\t    " << wt[i]
                    << "\t\t  " << tat[i] << endl;
            }
        
            cout << "\nAverage waiting time = "
                << (float)total_wt / (float)n;
            cout << "\nAverage turn around time = "
                << (float)total_tat / (float)n;
        }
        
        void priorityScheduling(Process proc[], int n)
        {
            // Sort processes by priority
            sort(proc, proc + n, comparison);
        
            cout<< "Order in which processes gets executed \n";
            for (int  i = 0 ; i <  n; i++)
                cout << proc[i].pid <<" " ;
        
            findavgTime(proc, n);
        }
        
        // Driver code
        int main()
        {
            Process proc[] = {{1, 10, 2}, {2, 5, 0}, {3, 8, 1}};
            int n = sizeof proc / sizeof proc[0];
            priorityScheduling(proc, n);
            return 0;
        }
    </div>
    <h1>Bankers algo</h1>
    <div>
        #include -iostream-
        using namespace std;
            
        int main()
        {
            
            int n, m, i, j, k;
            n = 5;
            m = 3;
            int alloc[5][3] = {{0, 1, 0},
                                {2, 0, 0},
                                {3, 0, 2},
                                {2, 1, 1},
                                {0, 0, 2}};
            
            int max[5][3] = {{7, 5, 3},
                            {3, 2, 2},
                            {9, 0, 2},
                            {2, 2, 2},
                            {4, 3, 3}};
            
            int avail[3] = {3, 3, 2};
            
            int f[n], ans[n], ind = 0;
            for (k = 0; k < n; k++)
            {
                f[k] = 0;
            }
            int need[n][m];
            for (i = 0; i < n; i++)
            {
                for (j = 0; j < m; j++)
                    need[i][j] = max[i][j] - alloc[i][j];
            }
            int y = 0;
            for (k = 0; k < 5; k++)
            {
                for (i = 0; i < n; i++)
                {
                    if (f[i] == 0)
                    {
            
                        int flag = 0;
                        for (j = 0; j < m; j++)
                        {
                            if (need[i][j] > avail[j])
                            {
                                flag = 1;
                                break;
                            }
                        }
            
                        if (flag == 0)
                        {
                            ans[ind++] = i;
                            for (y = 0; y < m; y++)
                                avail[y] += alloc[i][y];
                            f[i] = 1;
                        }
                    }
                }
            }
            
            int flag = 1;
            
            for (int i = 0; i < n; i++)
            {
                if (f[i] == 0)
                {
                    flag = 0;
                    cout << "The given sequence is not safe";
                    break;
                }
            }
            
            if (flag == 1)
            {
                cout << "Following is the SAFE Sequence" << endl;
                for (i = 0; i < n - 1; i++)
                    cout << " P" << ans[i] << " ->";
                cout << " P" << ans[n - 1] << endl;
            }
            
            return (0);
        }
    </div>
    <h1>PAGE REPLACEMENT FCFS</h1>
    <div>
        #include-bits/stdc++.h-
        using namespace std;
        int pageFaults(int pages[], int n, int capacity)
        {
        
        unordered_set<int> s;
        queue<int> indexes;
        
        int page_faults = 0;
        for (int i=0; i< n; i++)
        {
            if (s.size() < capacity)
            {
                
                if (s.find(pages[i])==s.end())
                {
                    
                    s.insert(pages[i]);
                        page_faults++;
                    indexes.push(pages[i]);
                }
            }
            else
            {   
                if (s.find(pages[i]) == s.end())
                {
                    int val = indexes.front();
                    indexes.pop();
                    s.erase(val);
                    s.insert(pages[i]);
                    indexes.push(pages[i]);
                    page_faults++;
                }
            }
        }
        return page_faults;
        }
        int main()
        {
        int pages[] = {7, 0, 1, 2, 0, 3, 0, 4,
                        2, 3, 0, 3, 2};
        int n = sizeof(pages)/sizeof(pages[0]);
        int capacity = 4;
        cout << pageFaults(pages, n, capacity);
        return 0;
        }
    </div>
    <h1>PAGE REPLACEMENT LRU</h1>
    <div>
        #include -bits/stdc++.h-
        using namespace std;
        
        int pageFaults(int pages[], int n, int capacity)
        {
        
        unordered_set<int> s;
        
        unordered_map<int, int> indexes;
        
        int page_faults = 0;
        for (int i = 0; i < n; i++)
        {
            if (s.size() < capacity)
            {
        
                if (s.find(pages[i]) == s.end())
                {
                    s.insert(pages[i]);
        
                    page_faults++;
                }
        
                indexes[pages[i]] = i;
            }
        
            else
            {
        
                if (s.find(pages[i]) == s.end())
                {
        
                    int lru = INT_MAX, val;
                    for (auto it = s.begin(); it != s.end(); it++)
                    {
                        if (indexes[*it] < lru)
                        {
                            lru = indexes[*it];
                            val = *it;
                        }
                    }
        
                    s.erase(val);
        
                    s.insert(pages[i]);
        
                    page_faults++;
                }
        
                indexes[pages[i]] = i;
            }
        }
        
        return page_faults;
        }
        
        int main()
        {
        int pages[] = {7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2};
        int n = sizeof(pages) / sizeof(pages[0]);
        int capacity = 4;
        cout << pageFaults(pages, n, capacity);
        return 0;
        }
    </div>
    <h1>OPTIMAL PAGE</h1>
    <div>int main()
        {
           int no_of_frames, no_of_pages, frames[10], pages[30], temp[10], flag1, flag2, flag3, i, j, k, pos, max, faults = 0;
           printf("Enter number of frames: ");
           scanf("%d", &no_of_frames);
         
           printf("Enter number of pages: ");
           scanf("%d", &no_of_pages);
         
           printf("Enter page reference string: ");
         
           for (i = 0; i < no_of_pages; ++i)
           {
               scanf("%d", &pages[i]);
           }
         
           for (i = 0; i < no_of_frames; ++i)
           {
               frames[i] = -1;
           }
         
           for (i = 0; i < no_of_pages; ++i)
           {
               flag1 = flag2 = 0;
         
               for (j = 0; j < no_of_frames; ++j)
               {
                   if (frames[j] == pages[i])
                   {
                       flag1 = flag2 = 1;
                       break;
                   }
               }
         
               if (flag1 == 0)
               {
                   for (j = 0; j < no_of_frames; ++j)
                   {
                       if (frames[j] == -1)
                       {
                           faults++;
                           frames[j] = pages[i];
                           flag2 = 1;
                           break;
                       }
                   }
               }
         
               if (flag2 == 0)
               {
                   flag3 = 0;
         
                   for (j = 0; j < no_of_frames; ++j)
                   {
                       temp[j] = -1;
         
                       for (k = i + 1; k < no_of_pages; ++k)
                       {
                           if (frames[j] == pages[k])
                           {
                               temp[j] = k;
                               break;
                           }
                       }
                   }
         
                   for (j = 0; j < no_of_frames; ++j)
                   {
                       if (temp[j] == -1)
                       {
                           pos = j;
                           flag3 = 1;
                           break;
                       }
                   }
         
                   if (flag3 == 0)
                   {
                       max = temp[0];
                       pos = 0;
         
                       for (j = 1; j < no_of_frames; ++j)
                       {
                           if (temp[j] > max)
                           {
                               max = temp[j];
                               pos = j;
                           }
                       }
                   }
                   frames[pos] = pages[i];
                   faults++;
               }
         
               printf("\n");
         
               for (j = 0; j < no_of_frames; ++j)
               {
                   printf("%d\t", frames[j]);
               }
           }
         
           printf("\n\nTotal Page Faults = %d", faults);
         
           return 0;
        }
        </div>
        <h1>SHELL SORT</h1>
        <div>
            # Sorting the array in Bash 
            # using Bubble sort

            # Static input of Array
            arr=(10 8 20 100 12)

            echo "Array in original order"
            echo ${arr[*]}

            # Performing Bubble sort 
            for ((i = 0; i< 5; i++))
            do
                
                for((j = 0; j< 5-i-1; j++))
                do
                
                    if [ ${arr[j]} -gt ${arr[$((j+1))]} ]
                    then
                        # swap
                        temp=${arr[j]}
                        arr[$j]=${arr[$((j+1))]}  
                        arr[$((j+1))]=$temp
                    fi
                done
            done

            echo "Array in sorted order :"
            echo ${arr[*]}
        </div>
        <h1>SHELL PRIME AND REVERSE</h1>
        <div>
            number=53
            i=2
            flag=0
            while test $i -le `expr $number / 2`
            do
            if test `expr $number % $i` -eq 0
            then
            flag=1
            fi

            i=`expr $i + 1`
            done if test $flag -eq 1
            then
            echo "The number is Not Prime"
            else
            echo "The number is Prime"
            Fi

            #reverse the number
            echo enter n
            read n
            num=0
            while [ $n -gt 0 ]
            do
            num=$(expr $num \* 10)
            k=$(expr $n % 10)
            num=$(expr $num + $k)
            n=$(expr $n / 10)
            done
            echo number is $num
        </div>
        <h1>SHELL PALINDROME</h1>
        <div>
            #! /bin/bash
            #Website : cs.sounak.in
            # Author: Sounak Pal
            ## Script to check a number palindrome or not
            echo &quot;Enter a Number&quot;
            read n
            temp=$n
            while ((temp>0))
            do
                ans=$((ans*10))
                mod=$((temp%10))
                ans=$((ans+mod))
                temp=$((temp/10))
            done
            if (($n == $ans))
            then
                echo "It's a Palindrome Number"
            else
            echo "It's not a Palindrome Number"
            fi
        </div>
        <h1>SHELL FACTORIAL</h1>
        <div>
            #withour recursion
            echo "Enter a number"
            read num

            fact=1

            while [ $num -gt 1 ]
            do
            fact=$((fact * num))  #fact = fact * num
            num=$((num - 1))      #num = num - 1
            done

            echo $fact



            #with recursion
            #!/bin/bash
            # Recursive factorial function

            factorial()
            {
                product=$1
                    
                # Defining a function to calculate factorial using recursion
                if((product <= 2)); then
                    echo $product
                else
                    f=$((product -1))
                    
            # Recursive call

            f=$(factorial $f)
            f=$((f*product))
            echo $f
            fi
            }

            # main program
            # reading the input from user
            echo "Enter the number:"   
            read num

            # defining a special case for 0! = 1
            if((num == 0)); then   
            echo 1
            else
            #calling the function
            factorial $num
            fi

        </div>
        <h1>OS CP</h1>
        <div>
            #include -iostream-
            #include -fstream-
            #include -string.h-
            #include -cstdlib-
            #include -time.h-
            #include -vector-
            using namespace std;
            
            ifstream fin("input.txt");
            ofstream fout("output.txt");
            
            char M[300][4], buffer[40], IR[4], R[4];
            int IC, C, SI, PI, TI, PTR, TTC, LLC;
            bool flagBreak;   // To indicate current job is terminated
            vector<int> allo; // To check repeat allocation in PTR
            
            struct PCB
            {
                int job_id;
                int TTL;
                int TLL;
            
                void setPCB(int id, int ttl, int tll)
                {
                    job_id = id;
                    TTL = ttl;
                    TLL = tll;
                }
            };
            
            PCB pcb;
            
            string error[9] = {"No Error", "Out of Data", "Line Limit Exceeded", "Time Limit Exceeded",
                                "Operation Code Error", "Operand Error", "Invalid Page Fault", "Time Limit Exceeded with opcode error", "Time Limit Exceeded with operand error"};
            
            void INIT();
            void READ(int RA);
            void WRITE(int RA);
            int ADDRESSMAP(int VA);
            void EXECUTE_USER_PROGRAM();
            void STARTEXECUTION();
            int ALLOCATE();
            void LOAD();
            
            void INIT()
            {
                memset(M, '\0', 1200);
                memset(IR, '\0', 4);
                memset(R, '\0', 4);
                C = 0;
                SI = 0;
                PI = 0;
                TI = 0;
                flagBreak = false;
            }
            
            void TERMINATE(int EM)
            {
                fout << endl;
                fout << "Job ID : " << pcb.job_id << endl
                        << error[EM] << endl;
                fout << "IC : " << IC << endl
                        << "IR : ";
                for (int i = 0; i < 4; i++)
                    fout << IR[i];
            
                fout << endl
                        << "TTC : " << TTC << endl
                        << "LLC : " << LLC;
                fout << endl
                        << endl;
            }
            
            void READ(int RA)
            {
                fin.getline(buffer, 41);
            
                char temp[5];
                memset(temp, '\0', 5);
                memcpy(temp, buffer, 4);
            
                if (!strcmp(temp, "$END"))
                {
                    TERMINATE(1);
                    flagBreak = true;
                }
                else
                {
                    strcpy(M[RA], buffer);
                }
            }
            
            void WRITE(int RA)
            {
                if (LLC + 1 > pcb.TLL)
                {
                    TERMINATE(2);
                    flagBreak = true;
                }
                else
                {
                    string str; //! Changed to string
                    int k = 0;
                    for (int i = RA; i < (RA + 10); i++)
                    {
                        for (int j = 0; j < 4; j++)
                            str += M[i][j];
                    }
                    fout << str << endl;
                    LLC++;
                }
            }
            
            int MOS(int RA = 0)
            {
                if (TI == 0)
                {
                    if (SI != 0)
                    {
                        switch (SI)
                        {
                        case 1:
                            READ(RA);
                            break;
                        case 2:
                            WRITE(RA);
                            break;
                        case 3:
                            TERMINATE(0);
                            flagBreak = true;
                            break;
                        default:
                            cout << "Error with SI." << endl;
                        }
                        SI = 0;
                    }
                    // Page Fault checking
                    else if (PI != 0)
                    {
                        switch (PI)
                        {
                        case 1:
                            TERMINATE(4);
                            flagBreak = true;
                            break;
                        case 2:
                            TERMINATE(5);
                            flagBreak = true;
                            break;
                        case 3:
                            PI = 0;
                            char temp[3];
                            memset(temp, '\0', 3);
                            memcpy(temp, IR, 2);
                            // valid page fault
                            if (!strcmp(temp, "GD") || !strcmp(temp, "SR"))
                            {
                                int m;
                                do
                                {
                                    m = ALLOCATE();
                                } while (M[m * 10][0] != '\0');
                                int currPTR = PTR;
                                while (M[currPTR][0] != '0')
                                    currPTR++;
            
                                char temp1[2];
                                sprintf(temp1, "%d", m);
                                M[currPTR][0] = '1';
            
                                if (m < 10)
                                {
                                    M[currPTR][2] = '0';
                                    M[currPTR][3] = temp1[0];
                                }
                                else
                                {
                                    M[currPTR][2] = temp1[0];
                                    M[currPTR][3] = temp1[1];
                                }
            
                                if (TTC + 1 > pcb.TTL)
                                {
                                    TI = 2;
                                    PI = 3;
                                    MOS();
                                    break;
                                }
                                return 1;
                            }
                            else if (!strcmp(temp, "PD") || !strcmp(temp, "LR") || !strcmp(temp, "H") || !strcmp(temp, "CR") || !strcmp(temp, "BT"))
                            {
                                TERMINATE(6);
                                flagBreak = true;
            
                                if (TTC + 1 > pcb.TTL)
                                {
                                    TI = 2;
                                    PI = 3;
                                    MOS();
                                    break;
                                }
                            }
                            else
                            {
                                PI = 1;
                                MOS();
                            }
                            return 0;
                        default:
                            cout << "Error with PI." << endl;
                        }
                        PI = 0;
                    }
                }
                else
                {
                    if (SI != 0)
                    {
                        switch (SI)
                        {
                        case 1:
                            TERMINATE(3);
                            flagBreak = true;
                            break;
                        case 2:
                            WRITE(RA);
                            if (!flagBreak)
                                TERMINATE(3);
                            flagBreak = true; //! check
                            break;
                        case 3:
                            TERMINATE(0);
                            flagBreak = true;
                            break;
                        default:
                            cout << "Error with SI." << endl;
                        }
                        SI = 0;
                    }
                    else if (PI != 0)
                    {
                        switch (PI)
                        {
                        case 1:
                            TERMINATE(7);
                            flagBreak = true;
                            break;
                        case 2:
                            TERMINATE(8);
                            flagBreak = true;
                            break;
                        case 3:
                            TERMINATE(3);
                            flagBreak = true;
                            break;
                        default:
                            cout << "Error with PI." << endl;
                        }
                        PI = 0;
                    }
                }
            
                return 0;
            }
            
            void increment()
            {
                TTC++;
                if (TTC + 1 > pcb.TTL)
                {
                    TI = 2;
                }
            }
            
            int ADDRESSMAP(int VA)
            {
                if (0 <= VA && VA < 100)
                {
                    int pte = PTR + VA / 10; // 112
            
                    if (M[pte][0] == '0')
                    {
                        PI = 3;
                        return 0;
                    }
            
                    char temp[2];
                    temp[0] = M[pte][2];
                    temp[1] = M[pte][3];
                    int RA = atoi(temp) * 10 + VA % 10;
                    return RA;
                }
                PI = 2;
                return 0;
            }
            
            void EXECUTE_USER_PROGRAM()
            {
                char opcode[3], operand[2];
                int locIR, RA;
            
                while (true)
                {
                    if (flagBreak)
                        break;
            
                    RA = ADDRESSMAP(IC);
                    if (PI != 0)
                    {
                        if (MOS())
                        {
                            continue;
                        }
                        break;
                    }
                    memcpy(IR, M[RA], 4);
                    IC += 1;
            
                    memset(opcode, '\0', 3);
                    memcpy(opcode, IR, 2);
                    for (int i = 0; i < 2; i++)
                    {
                        if (!((47 < IR[i + 2] && IR[i + 2] < 58) || IR[i + 2] == 0))
                        {
                            PI = 2;
                            break;
                        }
                        operand[i] = IR[i + 2];
                    }
            
                    if (PI != 0)
                    {
                        MOS();
                        break;
                    }
            
                    locIR = atoi(operand);
            
                    RA = ADDRESSMAP(locIR);
                    if (PI != 0)
                    {
                        if (MOS())
                        {
                            IC--;
                            continue;
                        }
                        break;
                    }
            
                    if (!strcmp(opcode, "LR"))
                    {
            
                        cout << endl;
                        for (int i = 0; i < 4; i++)
                        {
                            R[i] = M[RA][i];
                        }
                        increment();
                    }
                    else if (!strcmp(opcode, "SR"))
                    {
            
                        for (int i = 0; i < 4; i++)
                        {
                            M[RA][i] = R[i];
                        }
                        TTC = TTC + 2;
                        if (TTC + 2 > pcb.TTL)
                        {
                            TI = 2;
                        }
                    }
                    else if (!strcmp(opcode, "CR"))
                    {
            
                        if (!strcmp(R, M[RA]))
                            C = 1;
                        else
                            C = 0;
                        increment();
                    }
                    else if (!strcmp(opcode, "BT"))
                    {
            
                        if (C == 1)
                            IC = RA;
                        increment();
                    }
                    else if (!strcmp(opcode, "GD"))
                    {
                        SI = 1;
                        TTC = TTC + 2;
                        if (TTC + 2 > pcb.TTL)
                        {
                            TI = 2;
                        }
                        MOS(RA);
                    }
                    else if (!strcmp(opcode, "PD"))
                    {
                        SI = 2;
                        increment();
                        MOS(RA);
                    }
                    else if (!strcmp(opcode, "H"))
                    {
                        SI = 3;
                        increment();
                        MOS();
            
                        break;
                    }
                    else
                    {
                        PI = 1;
                        MOS();
                        break;
                    }
                    memset(IR, '\0', 4);
                }
                // for(int i=0; i< 300; i++){
                //                 cout<< i< <" ";
                //             for(int j=0 ; j< 4; j++){
                //                 cout<< M[i][j]<<" ";
                //             }
                //             cout<< endl;
                //         }
            }
            
            void STARTEXECUTION()
            {
                IC = 0;
                EXECUTE_USER_PROGRAM();
            }
            
            int ALLOCATE()
            {
                int random = rand() % 30;
                if (allo.size() == 0)
                {
                    allo.push_back(random);
                    return allo[0];
                }
                for (int i = 0; i < allo.size(); i++)
                {
                    if (random == allo[i])
                    {
                        return ALLOCATE();
                    }
                }
                allo.push_back(random);
            
                return allo[allo.size() - 1];
            }
            
            void LOAD()
            {
                int m;        // Variable to hold memory loction
                int currPTR;  // Points to the last empty loction in Page Table Register
                char temp[5]; // Temporary Variable to check for $AMJ, $DTA, $END
                memset(buffer, '\0', 40);
            
                while (!fin.eof())
                {
                    fin.getline(buffer, 41);
                    memset(temp, '\0', 5);
                    memcpy(temp, buffer, 4);
            
                    if (!strcmp(temp, "$AMJ"))
                    { // if 0 then false (strcmp=0 if same)
                        INIT();
                        srand(time(0));
                        int jobId, TTL, TLL;
                        memcpy(temp, buffer + 4, 4);
                        jobId = atoi(temp);
                        memcpy(temp, buffer + 8, 4);
                        TTL = atoi(temp);
                        memcpy(temp, buffer + 12, 4);
                        TLL = atoi(temp);
                        pcb.setPCB(jobId, TTL, TLL);
                        TTC = 0;
                        LLC = 0;
                        PTR = ALLOCATE() * 10;
            
                        memset(M[PTR], '*', 40);
                        for (int i = 0; i < 10; i++)
                        {
                            M[PTR + i][0] = '0';
                        }
                        currPTR = PTR;
                    }
                    else if (!strcmp(temp, "$DTA"))
                    {
                        STARTEXECUTION();
                    }
                    else if (!strcmp(temp, "$END"))
                    {
                        continue;
                    }
                    else
                    {
                        if (flagBreak)
                            continue;
            
                        do
                        {
                            m = ALLOCATE();
                        } while (M[m * 10][0] != '\0');
                        char temp[2];
                        sprintf(temp, "%d", m);
                        M[currPTR][0] = '1'; // flag set
            
                        if (m < 10)
                        {
                            M[currPTR][2] = '0';
                            M[currPTR][3] = temp[0];
                        }
                        else
                        {
                            M[currPTR][2] = temp[0];
                            M[currPTR][3] = temp[1];
                        }
            
                        currPTR++;
            
                        strcpy(M[m * 10], buffer);
            
                        cout << "PTR = " << PTR << endl;
            
                        cout << endl;
                    }
                }
            }
            
            int main()
            {
                LOAD();
                cout << "Execution Completed!";
                fin.close();
                fout.close();
                return 0;
            }
        </div>
  </body>
</html>
